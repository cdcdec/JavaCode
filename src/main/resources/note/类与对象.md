# 类与对象

## 构造函数

如果一个非抽象类没有声明任何(主或次)构造函数,
它会有一个生成的不带参数的主构造函数。
构造函数的可见性是public。如果你不希望你的类有一个公有构造函数，
你需要声明一个带有非默认可见性的空的主构造函数
```
//如果构造函数有注解或可见性修饰符，
//这个constructor关键字是必需的，并且这些修饰符在它前面
class ClassDemo6 private constructor(){
    
}
//下面的调用会报错,并且ClassDemo6类中的init(初始化代码块)也不会被调用.
var demo6=ClassDemo6()

```

### 初始化代码块
初始化块中的代码实际上会成为主构造函数的一部分。
委托给主构造函数会作为次构造函数的第一条语句，
因此所有初始化块中的代码都会在次构造函数体之前执行。
即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块.
但是如果主构造函数被private修饰,那么初始化代码块就不会被执行。
主构造函数不能包含任何的代码。
初始化的代码可以放到以init关键字作为前缀的初始化块（initializer blocks）中。
在实例初始化期间，初始化块按照它们出现在类体中的顺序执行.

```
class A{
init{
    //初始化代码块1
    .......
}

init{
    //初始化代码块2
    .......
}

}
```



### 主构造函数
在Kotlin中的一个类可以有一个或零个主构造函数以及一个或多个次构造函数。
主构造函数是类头的一部分：它跟在类名（与可选的类型参数）后。
```
//此处的constructor可以省略不写  含有参数的主构造函数
 class ClassDemo1 constructor(name:String,var city:String,val country:String){
     val firstProperty = "First property: $name".also(::println)
     init {
         //name没有在主函数中声明,只能在初始化块以及属性声明中使用
         println("First initializer block that prints $name")
         //city和country在主函数中声明了,可以当做全局变量使用
     }
     //name没有在主函数中声明,只能在初始化块以及属性声明中使用
     val secondProperty = "Second property: ${name.length}".also(::println)
 
     init {
         println("Second initializer block that prints ${name.length}")
     }
     //没有在主函数中声明,但是在类中声明了,也可以作为全局变量使用
     var name=name//这样声明后可以作为全局变量使用
 
     fun t1(){
         "在方法中使用构造函数中定义的变量:$name".also(::println)
         "在方法中使用构造函数中定义的变量:$city，$country".also(::println)
     }
 }
 
 
 //此处的constructor可以省略不写  不含参数的主构造函数
 class ClassDemo1 constructor(){
      
 }
 
 //没有主构造函数,有次构造函数
 class ClassDemo3{
     var name=""
     constructor(name:String){
         this.name=name
     }
     fun p(){
         println(name)
     }
 }
 
 //有无参数的主构造函数,还有一个次构造函数.次构造函数需要委托给主构造函数
 class ClassDemo4 constructor(){
     var name=""
     constructor(name:String):this(){
         this.name=name
     }
     fun p(){
         println(name)
     }
 }

```

### 次构造函数
在Kotlin中的一个类可以有一个主构造函数以及一个或多个次构造函数。
如果类有一个主构造函数,每个次构造函数需要委托给主构造函数,
可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用this关键字即可
```
class ClassDemo5 constructor(name:String){
    var city=""
    var country=""
    var name=name
    constructor(city:String,name:String):this(name){
        this.city=city
        println("city=$city")
    }
    constructor(city:String,name:String,country:String):this(city){
        this.country=country
        println("country=$country，city=$city")
    }
}

```





## 类中的静态属性和静态方法

``` 
class ClassDemo2{
    //类中的静态属性和静态方法
    companion object {
        fun staticMethod1(){
            println("类中的静态方法1")
        }
        val staticPro1="类中的静态属性1"

        @JvmStatic //可以不加  这只会影响通过java调用此方法的写法
        fun staticMethod2(){
            println("类中的静态方法2")
        }

        @JvmField //可以不加  这只会影响通过java调用此方法的写法
        val staticPro2="类中的静态属性2"
    }
}

```

### 1.在kotlin中调用kotlin类的静态属性和方法
```
fun main(args: Array<String>) {
    println(ClassDemo2.staticPro1)
    ClassDemo2.staticMethod1()
    println("kotlin中调用")
    println(ClassDemo2.staticPro2)
    ClassDemo2.staticMethod2()
}

```

### 2.在java中调用kotlin类的静态属性和方法
```
  ClassDemo2.Companion.staticMethod1();
  System.out.println(ClassDemo2.Companion.getStaticPro1());
  ClassDemo2.Companion.staticMethod2();
  System.out.println(ClassDemo2.staticPro2);
  ClassDemo2.staticMethod2();

```

### 3.注解JvmStatic和JvmField
伴生函数：在"companion object"中的公共函数必须用使用 @JvmStatic注解才能暴露为静态方法。如果没有这个注解,这些函数仅可用作静态Companion字段上的实例方法。
伴生常量:在 companion object 中的公共、非 const 的属性 实际上为常量 必须用 @JvmField 注解才能暴露为静态字段。
如果没有这个注解，这些属性只能作为静态 Companion 字段中奇怪命名的 ‘getters’ 实例。